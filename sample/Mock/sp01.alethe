(assume a0 (not p))
(assume a1 (not (not (or p q r))))
(assume a2 (not (not (or p (not q)))))
(assume a3 (not r))
(anchor :step t1)
(assume t1.a0 (or p q r))
(assume t1.a1 (not p))
(assume t1.a2 (or p (not q)))
(step t1.t1 (cl p q r) :rule or :premises (t1.a0))
(step t1.t2 (cl p (not q)) :rule or :premises (t1.a2))
(step t1.t3 (cl q r) :rule resolution :premises (t1.t1 t1.a1) :args (p true))
(step t1.t4 (cl p r) :rule resolution :premises (t1.t3 t1.t2) :args (q true))
(step t1.t5 (cl r) :rule resolution :premises (t1.t4 t1.a1) :args(p true))
(step t1 (cl (not (or p q r)) (not (not p)) (not (or p (not q))) r ) :rule subproof :discharge(t1.a0 t1.a1 t1.a2))
(step t2 (cl (not (not p)) (not (or p (not q))) r) :rule resolution :premises (a1 t1) :args((not (or p q r)) false))
(step t3 (cl (not (not p)) r) :rule resolution :premises (t2 a2) :args((not (or p (not q))) true))
(step t4 (cl r) :rule resolution :premises (t3 a0) :args((not p) false))
(step t5 (cl) :rule resolution :premises (t4 a3) :args(r true))