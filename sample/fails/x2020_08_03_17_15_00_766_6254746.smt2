; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=20
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort S$ 0)
(declare-sort Nat$ 0)
(declare-sort Enat$ 0)
(declare-sort S_set$ 0)
(declare-sort V_set$ 0)
(declare-sort S_v_hd$ 0)
(declare-sort S_v_tm$ 0)
(declare-sort S_nat_fun$ 0)
(declare-sort S_enat_fun$ 0)
(declare-sort V_multiset$ 0)
(declare-sort S_v_tm_list$ 0)
(declare-sort V_s_set_fun$ 0)
(declare-sort S_v_tm_bool_fun$ 0)
(declare-sort S_s_bool_fun_fun$ 0)
(declare-sort S_v_tm_list_bool_fun$ 0)
(declare-sort S_v_tm_s_v_tm_bool_fun_fun$ 0)
(declare-sort S_v_tm_list_s_v_tm_list_bool_fun_fun$ 0)
(declare-sort S_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun$ 0)
(declare-sort S_s_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun_fun$ 0)
(declare-fun s$ () S_v_tm$)
(declare-fun t$ () S_v_tm$)
(declare-fun gt$ (V_s_set_fun$ S_s_bool_fun_fun$ Nat$ S_s_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun_fun$ S_enat_fun$ S_nat_fun$) S_v_tm_s_v_tm_bool_fun_fun$)
(declare-fun wt$ (V_s_set_fun$ Nat$ S_enat_fun$ S_nat_fun$ S_v_tm$) Nat$)
(declare-fun arg$ (S_v_tm$) S_v_tm$)
(declare-fun bot$ () V_set$)
(declare-fun one$ () Nat$)
(declare-fun args$ (S_v_tm$) S_v_tm_list$)
(declare-fun extf$ () S_s_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun_fun$)
(declare-fun head$ (S_v_tm$) S_v_hd$)
(declare-fun less$ (Nat$ Nat$) Bool)
(declare-fun one$a () Enat$)
(declare-fun size$ (S_v_tm_list$) Nat$)
(declare-fun vars$ (S_v_tm$) V_set$)
(declare-fun zero$ () Nat$)
(declare-fun delta$ () Nat$)
(declare-fun gt_hd$ (S_s_bool_fun_fun$ V_s_set_fun$ S_v_hd$ S_v_hd$) Bool)
(declare-fun gt_sym$ () S_s_bool_fun_fun$)
(declare-fun is_Var$ (S_v_hd$) Bool)
(declare-fun member$ (S$ S_set$) Bool)
(declare-fun wt_sym$ () S_nat_fun$)
(declare-fun comp_hd$ (S_s_bool_fun_fun$ V_s_set_fun$ S_v_hd$ S_v_hd$) Bool)
(declare-fun fun_app$ (S_v_tm_bool_fun$ S_v_tm$) Bool)
(declare-fun less_eq$ (V_set$ V_set$) Bool)
(declare-fun fun_app$a (S_v_tm_s_v_tm_bool_fun_fun$ S_v_tm$) S_v_tm_bool_fun$)
(declare-fun fun_app$b (S_enat_fun$ S$) Enat$)
(declare-fun fun_app$c (S_nat_fun$ S$) Nat$)
(declare-fun fun_app$d (S_v_tm_list_bool_fun$ S_v_tm_list$) Bool)
(declare-fun fun_app$e (S_v_tm_list_s_v_tm_list_bool_fun_fun$ S_v_tm_list$) S_v_tm_list_bool_fun$)
(declare-fun fun_app$f (S_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun$ S_v_tm_s_v_tm_bool_fun_fun$) S_v_tm_list_s_v_tm_list_bool_fun_fun$)
(declare-fun fun_app$g (S_s_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun_fun$ S$) S_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun$)
(declare-fun gt_unary$ (V_s_set_fun$ S_s_bool_fun_fun$ Nat$ S_s_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun_fun$ S_enat_fun$ S_nat_fun$ S_v_tm$ S_v_tm$) Bool)
(declare-fun arity_sym$ () S_enat_fun$)
(declare-fun vars_mset$ (S_v_tm$) V_multiset$)
(declare-fun ground_heads$ (V_s_set_fun$ S_v_hd$) S_set$)
(declare-fun subseteq_mset$ (V_multiset$ V_multiset$) Bool)
(declare-fun ground_heads_var$ () V_s_set_fun$)
(assert (! (= (vars$ t$) bot$) :named a0))
(assert (! (forall ((?v0 S_v_tm$)) (=> (= (vars$ ?v0) bot$) (not (is_Var$ (head$ ?v0))))) :named a1))
(assert (! (forall ((?v0 S_v_tm$) (?v1 S_v_tm$)) (= (fun_app$ (fun_app$a (gt$ ground_heads_var$ gt_sym$ delta$ extf$ arity_sym$ wt_sym$) ?v0) ?v1) (or (exists ((?v2 S_v_tm$) (?v3 S_v_tm$)) (and (= ?v0 ?v2) (and (= ?v1 ?v3) (and (subseteq_mset$ (vars_mset$ ?v3) (vars_mset$ ?v2)) (less$ (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v3) (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v2)))))) (or (exists ((?v2 S_v_tm$) (?v3 S_v_tm$)) (and (= ?v0 ?v2) (and (= ?v1 ?v3) (and (= (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v2) (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v3)) (and (not (comp_hd$ gt_sym$ ground_heads_var$ (head$ ?v2) (head$ ?v3))) (and (= (size$ (args$ ?v2)) one$) (and (exists ((?v4 S$)) (and (member$ ?v4 (ground_heads$ ground_heads_var$ (head$ ?v2))) (and (= (fun_app$b arity_sym$ ?v4) one$a) (= (fun_app$c wt_sym$ ?v4) zero$)))) (or (fun_app$ (fun_app$a (gt$ ground_heads_var$ gt_sym$ delta$ extf$ arity_sym$ wt_sym$) (arg$ ?v2)) ?v3) (= (arg$ ?v2) ?v3))))))))) (or (exists ((?v2 S_v_tm$) (?v3 S_v_tm$)) (and (= ?v0 ?v2) (and (= ?v1 ?v3) (and (subseteq_mset$ (vars_mset$ ?v3) (vars_mset$ ?v2)) (and (= (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v2) (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v3)) (gt_hd$ gt_sym$ ground_heads_var$ (head$ ?v2) (head$ ?v3))))))) (exists ((?v2 S_v_tm$) (?v3 S_v_tm$)) (and (= ?v0 ?v2) (and (= ?v1 ?v3) (and (subseteq_mset$ (vars_mset$ ?v3) (vars_mset$ ?v2)) (and (= (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v2) (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v3)) (and (= (head$ ?v2) (head$ ?v3)) (forall ((?v4 S$)) (=> (member$ ?v4 (ground_heads$ ground_heads_var$ (head$ ?v2))) (fun_app$d (fun_app$e (fun_app$f (fun_app$g extf$ ?v4) (gt$ ground_heads_var$ gt_sym$ delta$ extf$ arity_sym$ wt_sym$)) (args$ ?v2)) (args$ ?v3))))))))))))))) :named a2))
(assert (! (forall ((?v0 S_v_tm$) (?v1 S_v_tm$)) (=> (fun_app$ (fun_app$a (gt$ ground_heads_var$ gt_sym$ delta$ extf$ arity_sym$ wt_sym$) ?v0) ?v1) (less_eq$ (vars$ ?v1) (vars$ ?v0)))) :named a3))
(assert (! (forall ((?v0 S_v_tm$) (?v1 S_v_tm$)) (=> (and (gt_unary$ ground_heads_var$ gt_sym$ delta$ extf$ arity_sym$ wt_sym$ ?v0 ?v1) (forall ((?v2 S_v_tm$) (?v3 S_v_tm$)) (=> (and (= ?v0 ?v2) (and (= ?v1 ?v3) (and (= (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v2) (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v3)) (and (not (comp_hd$ gt_sym$ ground_heads_var$ (head$ ?v2) (head$ ?v3))) (and (= (size$ (args$ ?v2)) one$) (and (exists ((?v4 S$)) (and (member$ ?v4 (ground_heads$ ground_heads_var$ (head$ ?v2))) (and (= (fun_app$b arity_sym$ ?v4) one$a) (= (fun_app$c wt_sym$ ?v4) zero$)))) (or (fun_app$ (fun_app$a (gt$ ground_heads_var$ gt_sym$ delta$ extf$ arity_sym$ wt_sym$) (arg$ ?v2)) ?v3) (= (arg$ ?v2) ?v3)))))))) false))) false)) :named a4))
(assert (! (forall ((?v0 S_v_hd$) (?v1 S_v_hd$)) (=> (not (comp_hd$ gt_sym$ ground_heads_var$ ?v0 ?v1)) (or (is_Var$ ?v1) (is_Var$ ?v0)))) :named a5))
(assert (! (forall ((?v0 V_set$)) (= (less_eq$ ?v0 bot$) (= ?v0 bot$))) :named a6))
(assert (! (not (not (gt_unary$ ground_heads_var$ gt_sym$ delta$ extf$ arity_sym$ wt_sym$ t$ s$))) :named a7))
(check-sat)
;;;;(get-proof)
