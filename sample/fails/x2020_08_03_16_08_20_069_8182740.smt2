; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=20
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort S$ 0)
(declare-sort Nat$ 0)
(declare-sort S_set$ 0)
(declare-sort V_set$ 0)
(declare-sort S_v_hd$ 0)
(declare-sort S_v_tm$ 0)
(declare-sort S_bool_fun$ 0)
(declare-sort S_enat_fun$ 0)
(declare-sort S_v_tm_list$ 0)
(declare-sort V_s_set_fun$ 0)
(declare-sort S_hmultiset_fun$ 0)
(declare-sort S_v_tm_bool_fun$ 0)
(declare-sort S_s_bool_fun_fun$ 0)
(declare-sort S_v_tm_s_v_tm_prod$ 0)
(declare-sort S_v_tm_list_bool_fun$ 0)
(declare-sort S_v_tm_s_v_tm_prod_set$ 0)
(declare-sort V_pvar_hmultiset_tpoly$ 0)
(declare-sort S_nat_hmultiset_fun_fun$ 0)
(declare-sort S_v_tm_s_v_tm_bool_fun_fun$ 0)
(declare-sort S_v_tm_s_v_tm_prod_bool_fun$ 0)
(declare-sort S_v_tm_list_s_v_tm_list_bool_fun_fun$ 0)
(declare-sort S_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun$ 0)
(declare-sort S_s_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun_fun$ 0)
(declare-fun gt$ (V_s_set_fun$ S_s_bool_fun_fun$ Nat$ S_s_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun_fun$ S_enat_fun$ S_hmultiset_fun$ S_nat_hmultiset_fun_fun$) S_v_tm_s_v_tm_bool_fun_fun$)
(declare-fun uu$ () S_v_tm_s_v_tm_bool_fun_fun$)
(declare-fun wt$ (V_s_set_fun$ Nat$ S_enat_fun$ S_hmultiset_fun$ S_nat_hmultiset_fun_fun$ S_v_tm$) V_pvar_hmultiset_tpoly$)
(declare-fun bot$ () V_set$)
(declare-fun uua$ () S_v_tm_s_v_tm_bool_fun_fun$)
(declare-fun args$ (S_v_tm$) S_v_tm_list$)
(declare-fun extf$ () S_s_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun_fun$)
(declare-fun head$ (S_v_tm$) S_v_hd$)
(declare-fun pair$ (S_v_tm$ S_v_tm$) S_v_tm_s_v_tm_prod$)
(declare-fun vars$ (S_v_tm$) V_set$)
(declare-fun delta$ () Nat$)
(declare-fun gt_hd$ (S_s_bool_fun_fun$ V_s_set_fun$ S_v_hd$ S_v_hd$) Bool)
(declare-fun gt_sym$ () S_s_bool_fun_fun$)
(declare-fun member$ (S$ S_set$) Bool)
(declare-fun wt_sym$ () S_hmultiset_fun$)
(declare-fun collect$ (S_bool_fun$) S_set$)
(declare-fun fun_app$ (S_v_tm_bool_fun$ S_v_tm$) Bool)
(declare-fun less_eq$ (S_set$ S_set$) Bool)
(declare-fun member$a (S_v_tm_s_v_tm_prod$ S_v_tm_s_v_tm_prod_set$) Bool)
(declare-fun relcomp$ (S_v_tm_s_v_tm_prod_set$ S_v_tm_s_v_tm_prod_set$) S_v_tm_s_v_tm_prod_set$)
(declare-fun coef_sym$ () S_nat_hmultiset_fun_fun$)
(declare-fun collect$a (S_v_tm_s_v_tm_prod_bool_fun$) S_v_tm_s_v_tm_prod_set$)
(declare-fun eq_tpoly$ (V_s_set_fun$ Nat$ S_enat_fun$ S_hmultiset_fun$ V_pvar_hmultiset_tpoly$ V_pvar_hmultiset_tpoly$) Bool)
(declare-fun fun_app$a (S_v_tm_s_v_tm_bool_fun_fun$ S_v_tm$) S_v_tm_bool_fun$)
(declare-fun fun_app$b (S_v_tm_list_bool_fun$ S_v_tm_list$) Bool)
(declare-fun fun_app$c (S_v_tm_list_s_v_tm_list_bool_fun_fun$ S_v_tm_list$) S_v_tm_list_bool_fun$)
(declare-fun fun_app$d (S_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun$ S_v_tm_s_v_tm_bool_fun_fun$) S_v_tm_list_s_v_tm_list_bool_fun_fun$)
(declare-fun fun_app$e (S_s_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun_fun$ S$) S_v_tm_s_v_tm_bool_fun_fun_s_v_tm_list_s_v_tm_list_bool_fun_fun_fun$)
(declare-fun fun_app$f (S_bool_fun$ S$) Bool)
(declare-fun fun_app$g (S_v_tm_s_v_tm_prod_bool_fun$ S_v_tm_s_v_tm_prod$) Bool)
(declare-fun ge_tpoly$ (V_s_set_fun$ Nat$ S_enat_fun$ S_hmultiset_fun$ V_pvar_hmultiset_tpoly$ V_pvar_hmultiset_tpoly$) Bool)
(declare-fun less_eq$a (S_v_tm_s_v_tm_prod_set$ S_v_tm_s_v_tm_prod_set$) Bool)
(declare-fun arity_sym$ () S_enat_fun$)
(declare-fun case_prod$ (S_v_tm_s_v_tm_bool_fun_fun$) S_v_tm_s_v_tm_prod_bool_fun$)
(declare-fun ground_heads$ (V_s_set_fun$ S_v_hd$) S_set$)
(declare-fun ground_heads_var$ () V_s_set_fun$)
(assert (! (forall ((?v0 S_v_tm$) (?v1 S_v_tm$)) (! (= (fun_app$ (fun_app$a uu$ ?v0) ?v1) (and (= (vars$ ?v1) bot$) (and (eq_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ coef_sym$ ?v1) (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ coef_sym$ ?v0)) (exists ((?v2 S_v_tm$) (?v3 S_v_tm$)) (and (= ?v1 ?v2) (and (= ?v0 ?v3) (and (ge_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ coef_sym$ ?v2) (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ coef_sym$ ?v3)) (gt_hd$ gt_sym$ ground_heads_var$ (head$ ?v2) (head$ ?v3))))))))) :pattern ((fun_app$ (fun_app$a uu$ ?v0) ?v1)))) :named a0))
(assert (! (forall ((?v0 S_v_tm$) (?v1 S_v_tm$)) (! (= (fun_app$ (fun_app$a uua$ ?v0) ?v1) (and (= (vars$ ?v1) bot$) (and (eq_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ coef_sym$ ?v1) (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ coef_sym$ ?v0)) (exists ((?v2 S_v_tm$) (?v3 S_v_tm$)) (and (= ?v1 ?v2) (and (= ?v0 ?v3) (and (ge_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ coef_sym$ ?v2) (wt$ ground_heads_var$ delta$ arity_sym$ wt_sym$ coef_sym$ ?v3)) (and (= (head$ ?v2) (head$ ?v3)) (forall ((?v4 S$)) (=> (member$ ?v4 (ground_heads$ ground_heads_var$ (head$ ?v2))) (fun_app$b (fun_app$c (fun_app$d (fun_app$e extf$ ?v4) (gt$ ground_heads_var$ gt_sym$ delta$ extf$ arity_sym$ wt_sym$ coef_sym$)) (args$ ?v2)) (args$ ?v3)))))))))))) :pattern ((fun_app$ (fun_app$a uua$ ?v0) ?v1)))) :named a1))
(assert (! (forall ((?v0 V_pvar_hmultiset_tpoly$) (?v1 V_pvar_hmultiset_tpoly$) (?v2 V_pvar_hmultiset_tpoly$)) (=> (and (eq_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v0 ?v1) (eq_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v1 ?v2)) (eq_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v0 ?v2))) :named a2))
(assert (! (forall ((?v0 V_pvar_hmultiset_tpoly$) (?v1 V_pvar_hmultiset_tpoly$) (?v2 V_pvar_hmultiset_tpoly$)) (=> (and (eq_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v0 ?v1) (ge_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v1 ?v2)) (ge_tpoly$ ground_heads_var$ delta$ arity_sym$ wt_sym$ ?v0 ?v2))) :named a3))
(assert (! (forall ((?v0 S$) (?v1 S_bool_fun$)) (= (member$ ?v0 (collect$ ?v1)) (fun_app$f ?v1 ?v0))) :named a4))
(assert (! (forall ((?v0 S_v_tm_s_v_tm_prod$) (?v1 S_v_tm_s_v_tm_prod_bool_fun$)) (= (member$a ?v0 (collect$a ?v1)) (fun_app$g ?v1 ?v0))) :named a5))
(assert (! (forall ((?v0 S_v_tm_s_v_tm_prod$) (?v1 S_v_tm_s_v_tm_prod_set$) (?v2 S_v_tm_s_v_tm_prod_set$)) (=> (and (member$a ?v0 (relcomp$ ?v1 ?v2)) (forall ((?v3 S_v_tm$) (?v4 S_v_tm$) (?v5 S_v_tm$)) (=> (and (= ?v0 (pair$ ?v3 ?v5)) (and (member$a (pair$ ?v3 ?v4) ?v1) (member$a (pair$ ?v4 ?v5) ?v2))) false))) false)) :named a6))
(assert (! (forall ((?v0 S_v_tm_s_v_tm_bool_fun_fun$) (?v1 S_v_tm$) (?v2 S_v_tm$)) (= (fun_app$g (case_prod$ ?v0) (pair$ ?v1 ?v2)) (fun_app$ (fun_app$a ?v0 ?v1) ?v2))) :named a7))
(assert (! (forall ((?v0 S_set$) (?v1 S_set$)) (=> (forall ((?v2 S$)) (=> (member$ ?v2 ?v0) (member$ ?v2 ?v1))) (less_eq$ ?v0 ?v1))) :named a8))
(assert (! (forall ((?v0 S_v_tm_s_v_tm_prod_set$) (?v1 S_v_tm_s_v_tm_prod_set$)) (=> (forall ((?v2 S_v_tm_s_v_tm_prod$)) (=> (member$a ?v2 ?v0) (member$a ?v2 ?v1))) (less_eq$a ?v0 ?v1))) :named a9))
(assert (! (not (less_eq$a (relcomp$ (collect$a (case_prod$ uu$)) (collect$a (case_prod$ uua$))) (collect$a (case_prod$ uu$)))) :named a10))
(check-sat)
;;;;(get-proof)
