unsat
(assume a0 (not (= (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$)))) (times$ (enat$ delta$) (arity_sym$ f$)))))
(assume a1 (= zero$ (enat$ zero$a)))
(assume a2 (forall ((?v0 Enat$) (?v1 Enat$)) (= (= (times$ ?v0 ?v1) infinity$) (or (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= ?v1 infinity$) (not (= ?v0 zero$)))))))
(assume a3 (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= (arity_sym$ ?v0) infinity$)))))
(assume a4 (forall ((?v0 Enat$)) (= (not (less$a zero$ ?v0)) (= ?v0 zero$))))
(assume a5 (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a))))
(assume a6 (forall ((?v0 Nat$)) (not (= infinity$ (enat$ ?v0)))))
(assume a7 (forall ((?v0 Enat$)) (=> (not (= ?v0 infinity$)) (= (enat$ (the_enat$ ?v0)) ?v0))))
(step t0 (cl (=> (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))) (not (= infinity$ (arity_sym$ f$)))) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))) :rule implies_neg1)
(anchor :step t1)
(assume t1.a0 (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))))
(step t1.t0 (cl (or (not (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))) (not (= infinity$ (arity_sym$ f$))))) :rule forall_inst :args (f$))
(step t1.t1 (cl (not (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))) (not (= infinity$ (arity_sym$ f$)))) :rule or :premises (t1.t0))
(step t1.t2 (cl (not (= infinity$ (arity_sym$ f$)))) :rule resolution :premises (t1.t1 t1.a0) :args ((forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))) false))
(step t1 (cl (not (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))) (not (= infinity$ (arity_sym$ f$)))) :rule subproof :discharge (t1.a0))
(step t2 (cl (=> (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))) (not (= infinity$ (arity_sym$ f$)))) (not (= infinity$ (arity_sym$ f$)))) :rule resolution :premises (t0 t1) :args ((forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))) true))
(step t3 (cl (=> (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))) (not (= infinity$ (arity_sym$ f$)))) (not (not (= infinity$ (arity_sym$ f$))))) :rule implies_neg2)
(step t4 (cl (=> (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))) (not (= infinity$ (arity_sym$ f$)))) (=> (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))) (not (= infinity$ (arity_sym$ f$))))) :rule resolution :premises (t2 t3) :args ((not (= infinity$ (arity_sym$ f$))) true))
(step t5 (cl (=> (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))) (not (= infinity$ (arity_sym$ f$))))) :rule contraction :premises (t4))
(step t6 (cl (not (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))) (not (= infinity$ (arity_sym$ f$)))) :rule implies :premises (t5))
(step t7 (cl (not (= (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= (arity_sym$ ?v0) infinity$)))) (or (not (less$ zero$a delta$)) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))))) (not (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= (arity_sym$ ?v0) infinity$))))) (or (not (less$ zero$a delta$)) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))))) :rule equiv_pos2)
(anchor :step t8 :args ((?v0 S$) (:= (?v0 S$) ?v0)))
(step t8.t0 (cl (= (less$ zero$a delta$) (less$ zero$a delta$))) :rule refl)
(step t8.t1 (cl (= (= (arity_sym$ ?v0) infinity$) (= infinity$ (arity_sym$ ?v0)))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= (arity_sym$ ?v0) infinity$) (= infinity$ (arity_sym$ ?v0))) 2 7))
(step t8.t2 (cl (= (not (= (arity_sym$ ?v0) infinity$)) (not (= infinity$ (arity_sym$ ?v0))))) :rule cong :premises (t8.t1))
(step t8.t3 (cl (= (=> (less$ zero$a delta$) (not (= (arity_sym$ ?v0) infinity$))) (=> (less$ zero$a delta$) (not (= infinity$ (arity_sym$ ?v0)))))) :rule cong :premises (t8.t0 t8.t2))
(step t8 (cl (= (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= (arity_sym$ ?v0) infinity$)))) (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= infinity$ (arity_sym$ ?v0))))))) :rule bind)
(step t9 (cl (= (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= infinity$ (arity_sym$ ?v0))))) (forall ((?v0 S$)) (or (not (less$ zero$a delta$)) (not (= infinity$ (arity_sym$ ?v0))))))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= infinity$ (arity_sym$ ?v0))))) (forall ((?v0 S$)) (or (not (less$ zero$a delta$)) (not (= infinity$ (arity_sym$ ?v0)))))) 13 7))
(step t10 (cl (= (forall ((?v0 S$)) (or (not (less$ zero$a delta$)) (not (= infinity$ (arity_sym$ ?v0))))) (or (not (less$ zero$a delta$)) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (forall ((?v0 S$)) (or (not (less$ zero$a delta$)) (not (= infinity$ (arity_sym$ ?v0))))) (or (not (less$ zero$a delta$)) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))))) 13 7))
(step t11 (cl (= (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= infinity$ (arity_sym$ ?v0))))) (or (not (less$ zero$a delta$)) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))))) :rule trans :premises (t9 t10))
(step t12 (cl (= (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= (arity_sym$ ?v0) infinity$)))) (or (not (less$ zero$a delta$)) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))))) :rule trans :premises (t8 t11))
(step t13 (cl (or (not (less$ zero$a delta$)) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))))) :rule resolution :premises (t7 t12 a3) :args ((= (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= (arity_sym$ ?v0) infinity$)))) (or (not (less$ zero$a delta$)) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))))) false (forall ((?v0 S$)) (=> (less$ zero$a delta$) (not (= (arity_sym$ ?v0) infinity$)))) false))
(step t14 (cl (not (less$ zero$a delta$)) (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))) :rule or :premises (t13))
(step t15 (cl (not (= (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (less$ zero$a delta$) (= delta$ zero$a)))) (not (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a))) (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (less$ zero$a delta$) (= delta$ zero$a))) :rule equiv_pos2)
(step t16 (cl (= (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))))) :rule refl)
(step t17 (cl (= (not (not (less$ zero$a delta$))) (less$ zero$a delta$))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (not (not (less$ zero$a delta$))) (less$ zero$a delta$)) 1 6))
(step t18 (cl (= (= delta$ zero$a) (= delta$ zero$a))) :rule refl)
(step t19 (cl (= (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (less$ zero$a delta$) (= delta$ zero$a)))) :rule cong :premises (t16 t17 t18))
(step t20 (cl (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) :rule equiv_pos2)
(step t21 (cl (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) (not (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))))) :rule or_neg :args (0))
(step t22 (cl (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) (not (not (not (less$ zero$a delta$))))) :rule or_neg :args (1))
(step t23 (cl (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) (not (= delta$ zero$a))) :rule or_neg :args (2))
(step t24 (cl (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a))) :rule resolution :premises (t20 t21 t22 t23) :args ((not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) true (not (not (less$ zero$a delta$))) true (= delta$ zero$a) true))
(step t25 (cl (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a))) :rule contraction :premises (t24))
(step t26 (cl (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (less$ zero$a delta$) (= delta$ zero$a))) :rule resolution :premises (t15 t19 t25) :args ((= (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (less$ zero$a delta$) (= delta$ zero$a))) false (or (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (not (not (less$ zero$a delta$))) (= delta$ zero$a)) false))
(step t27 (cl (not (= (not (less$ zero$a delta$)) (= delta$ zero$a))) (less$ zero$a delta$) (= delta$ zero$a)) :rule or :premises (t26))
(step t28 (cl (less$ zero$a delta$) (= delta$ zero$a) (not (= (not (less$ zero$a delta$)) (= delta$ zero$a)))) :rule reordering :premises (t27))
(step t29 (cl (and (= zero$ (enat$ zero$a)) (= delta$ zero$a)) (not (= zero$ (enat$ zero$a))) (not (= delta$ zero$a))) :rule and_neg)
(step t30 (cl (=> (and (= zero$ (enat$ zero$a)) (= delta$ zero$a)) (= zero$ (enat$ delta$))) (and (= zero$ (enat$ zero$a)) (= delta$ zero$a))) :rule implies_neg1)
(anchor :step t31)
(assume t31.a0 (= zero$ (enat$ zero$a)))
(assume t31.a1 (= delta$ zero$a))
(step t31.t0 (cl (=> (and (= delta$ zero$a) (= zero$ (enat$ zero$a))) (= zero$ (enat$ delta$))) (and (= delta$ zero$a) (= zero$ (enat$ zero$a)))) :rule implies_neg1)
(anchor :step t31.t1)
(assume t31.t1.a0 (= delta$ zero$a))
(assume t31.t1.a1 (= zero$ (enat$ zero$a)))
(step t31.t1.t0 (cl (= zero$a delta$)) :rule symm :premises (t31.t1.a0))
(step t31.t1.t1 (cl (= (enat$ zero$a) (enat$ delta$))) :rule cong :premises (t31.t1.t0))
(step t31.t1.t2 (cl (= zero$ (enat$ delta$))) :rule trans :premises (t31.t1.a1 t31.t1.t1))
(step t31.t1 (cl (not (= delta$ zero$a)) (not (= zero$ (enat$ zero$a))) (= zero$ (enat$ delta$))) :rule subproof :discharge (t31.t1.a0 t31.t1.a1))
(step t31.t2 (cl (not (and (= delta$ zero$a) (= zero$ (enat$ zero$a)))) (= delta$ zero$a)) :rule and_pos :args (0))
(step t31.t3 (cl (not (and (= delta$ zero$a) (= zero$ (enat$ zero$a)))) (= zero$ (enat$ zero$a))) :rule and_pos :args (1))
(step t31.t4 (cl (= zero$ (enat$ delta$)) (not (and (= delta$ zero$a) (= zero$ (enat$ zero$a)))) (not (and (= delta$ zero$a) (= zero$ (enat$ zero$a))))) :rule resolution :premises (t31.t1 t31.t2 t31.t3) :args ((= delta$ zero$a) false (= zero$ (enat$ zero$a)) false))
(step t31.t5 (cl (not (and (= delta$ zero$a) (= zero$ (enat$ zero$a)))) (not (and (= delta$ zero$a) (= zero$ (enat$ zero$a)))) (= zero$ (enat$ delta$))) :rule reordering :premises (t31.t4))
(step t31.t6 (cl (not (and (= delta$ zero$a) (= zero$ (enat$ zero$a)))) (= zero$ (enat$ delta$))) :rule contraction :premises (t31.t5))
(step t31.t7 (cl (=> (and (= delta$ zero$a) (= zero$ (enat$ zero$a))) (= zero$ (enat$ delta$))) (= zero$ (enat$ delta$))) :rule resolution :premises (t31.t0 t31.t6) :args ((and (= delta$ zero$a) (= zero$ (enat$ zero$a))) true))
(step t31.t8 (cl (=> (and (= delta$ zero$a) (= zero$ (enat$ zero$a))) (= zero$ (enat$ delta$))) (not (= zero$ (enat$ delta$)))) :rule implies_neg2)
(step t31.t9 (cl (=> (and (= delta$ zero$a) (= zero$ (enat$ zero$a))) (= zero$ (enat$ delta$))) (=> (and (= delta$ zero$a) (= zero$ (enat$ zero$a))) (= zero$ (enat$ delta$)))) :rule resolution :premises (t31.t7 t31.t8) :args ((= zero$ (enat$ delta$)) true))
(step t31.t10 (cl (=> (and (= delta$ zero$a) (= zero$ (enat$ zero$a))) (= zero$ (enat$ delta$)))) :rule contraction :premises (t31.t9))
(step t31.t11 (cl (not (and (= delta$ zero$a) (= zero$ (enat$ zero$a)))) (= zero$ (enat$ delta$))) :rule implies :premises (t31.t10))
(step t31.t12 (cl (and (= delta$ zero$a) (= zero$ (enat$ zero$a))) (not (= delta$ zero$a)) (not (= zero$ (enat$ zero$a)))) :rule and_neg)
(step t31.t13 (cl (and (= delta$ zero$a) (= zero$ (enat$ zero$a)))) :rule resolution :premises (t31.t12 t31.a1 t31.a0) :args ((= delta$ zero$a) false (= zero$ (enat$ zero$a)) false))
(step t31.t14 (cl (= zero$ (enat$ delta$))) :rule resolution :premises (t31.t11 t31.t13) :args ((and (= delta$ zero$a) (= zero$ (enat$ zero$a))) false))
(step t31 (cl (not (= zero$ (enat$ zero$a))) (not (= delta$ zero$a)) (= zero$ (enat$ delta$))) :rule subproof :discharge (t31.a0 t31.a1))
(step t32 (cl (not (and (= zero$ (enat$ zero$a)) (= delta$ zero$a))) (= zero$ (enat$ zero$a))) :rule and_pos :args (0))
(step t33 (cl (not (and (= zero$ (enat$ zero$a)) (= delta$ zero$a))) (= delta$ zero$a)) :rule and_pos :args (1))
(step t34 (cl (= zero$ (enat$ delta$)) (not (and (= zero$ (enat$ zero$a)) (= delta$ zero$a))) (not (and (= zero$ (enat$ zero$a)) (= delta$ zero$a)))) :rule resolution :premises (t31 t32 t33) :args ((= zero$ (enat$ zero$a)) false (= delta$ zero$a) false))
(step t35 (cl (not (and (= zero$ (enat$ zero$a)) (= delta$ zero$a))) (not (and (= zero$ (enat$ zero$a)) (= delta$ zero$a))) (= zero$ (enat$ delta$))) :rule reordering :premises (t34))
(step t36 (cl (not (and (= zero$ (enat$ zero$a)) (= delta$ zero$a))) (= zero$ (enat$ delta$))) :rule contraction :premises (t35))
(step t37 (cl (=> (and (= zero$ (enat$ zero$a)) (= delta$ zero$a)) (= zero$ (enat$ delta$))) (= zero$ (enat$ delta$))) :rule resolution :premises (t30 t36) :args ((and (= zero$ (enat$ zero$a)) (= delta$ zero$a)) true))
(step t38 (cl (=> (and (= zero$ (enat$ zero$a)) (= delta$ zero$a)) (= zero$ (enat$ delta$))) (not (= zero$ (enat$ delta$)))) :rule implies_neg2)
(step t39 (cl (=> (and (= zero$ (enat$ zero$a)) (= delta$ zero$a)) (= zero$ (enat$ delta$))) (=> (and (= zero$ (enat$ zero$a)) (= delta$ zero$a)) (= zero$ (enat$ delta$)))) :rule resolution :premises (t37 t38) :args ((= zero$ (enat$ delta$)) true))
(step t40 (cl (=> (and (= zero$ (enat$ zero$a)) (= delta$ zero$a)) (= zero$ (enat$ delta$)))) :rule contraction :premises (t39))
(step t41 (cl (not (and (= zero$ (enat$ zero$a)) (= delta$ zero$a))) (= zero$ (enat$ delta$))) :rule implies :premises (t40))
(step t42 (cl (not (= zero$ (enat$ zero$a))) (not (= delta$ zero$a)) (= zero$ (enat$ delta$))) :rule resolution :premises (t29 t41) :args ((and (= zero$ (enat$ zero$a)) (= delta$ zero$a)) true))
(step t43 (cl (not (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))) (not (= zero$ (enat$ delta$)))) :rule and_pos :args (1))
(step t44 (cl (not (= zero$ (enat$ delta$))) (not (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))))) :rule reordering :premises (t43))
(step t45 (cl (not (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))))) (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))) :rule or_pos)
(step t46 (cl (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))) (not (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))))) :rule reordering :premises (t45))
(step t47 (cl (not (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$))))) (= infinity$ (enat$ delta$))) :rule and_pos :args (0))
(step t48 (cl (= infinity$ (enat$ delta$)) (not (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))))) :rule reordering :premises (t47))
(step t49 (cl (or (not (forall ((?v0 Nat$)) (not (= infinity$ (enat$ ?v0))))) (not (= infinity$ (enat$ delta$))))) :rule forall_inst :args (delta$))
(step t50 (cl (not (forall ((?v0 Nat$)) (not (= infinity$ (enat$ ?v0))))) (not (= infinity$ (enat$ delta$)))) :rule or :premises (t49))
(step t51 (cl (not (= infinity$ (enat$ delta$)))) :rule resolution :premises (t50 a6) :args ((forall ((?v0 Nat$)) (not (= infinity$ (enat$ ?v0)))) false))
(step t52 (cl (not (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))))) :rule resolution :premises (t48 t51) :args ((= infinity$ (enat$ delta$)) true))
(step t53 (cl (not (= (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))))) (not (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$)))) (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))))) :rule equiv_pos2)
(step t54 (cl (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))) (not (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$)))) (not (= (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))))))) :rule reordering :premises (t53))
(step t55 (cl (not (or (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$))))))) (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$)))))) :rule or_pos)
(step t56 (cl (= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$))))) (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (not (or (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$)))))))) :rule reordering :premises (t55))
(step t57 (cl (not (= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$))))))) :rule not_symm :premises (a0))
(step t58 (cl (or (not (forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0)))))) (or (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$)))))))) :rule forall_inst :args ((times$ (enat$ delta$) (arity_sym$ f$))))
(step t59 (cl (not (forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0)))))) (or (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$))))))) :rule or :premises (t58))
(step t60 (cl (not (= (forall ((?v0 Enat$)) (=> (not (= ?v0 infinity$)) (= (enat$ (the_enat$ ?v0)) ?v0))) (forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0))))))) (not (forall ((?v0 Enat$)) (=> (not (= ?v0 infinity$)) (= (enat$ (the_enat$ ?v0)) ?v0)))) (forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0)))))) :rule equiv_pos2)
(anchor :step t61 :args ((?v0 Enat$) (:= (?v0 Enat$) ?v0)))
(step t61.t0 (cl (= (= ?v0 infinity$) (= infinity$ ?v0))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= ?v0 infinity$) (= infinity$ ?v0)) 2 7))
(step t61.t1 (cl (= (not (= ?v0 infinity$)) (not (= infinity$ ?v0)))) :rule cong :premises (t61.t0))
(step t61.t2 (cl (= (= (enat$ (the_enat$ ?v0)) ?v0) (= ?v0 (enat$ (the_enat$ ?v0))))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= (enat$ (the_enat$ ?v0)) ?v0) (= ?v0 (enat$ (the_enat$ ?v0)))) 2 7))
(step t61.t3 (cl (= (=> (not (= ?v0 infinity$)) (= (enat$ (the_enat$ ?v0)) ?v0)) (=> (not (= infinity$ ?v0)) (= ?v0 (enat$ (the_enat$ ?v0)))))) :rule cong :premises (t61.t1 t61.t2))
(step t61 (cl (= (forall ((?v0 Enat$)) (=> (not (= ?v0 infinity$)) (= (enat$ (the_enat$ ?v0)) ?v0))) (forall ((?v0 Enat$)) (=> (not (= infinity$ ?v0)) (= ?v0 (enat$ (the_enat$ ?v0))))))) :rule bind)
(step t62 (cl (= (forall ((?v0 Enat$)) (=> (not (= infinity$ ?v0)) (= ?v0 (enat$ (the_enat$ ?v0))))) (forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0))))))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (forall ((?v0 Enat$)) (=> (not (= infinity$ ?v0)) (= ?v0 (enat$ (the_enat$ ?v0))))) (forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0)))))) 13 7))
(step t63 (cl (= (forall ((?v0 Enat$)) (=> (not (= ?v0 infinity$)) (= (enat$ (the_enat$ ?v0)) ?v0))) (forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0))))))) :rule trans :premises (t61 t62))
(step t64 (cl (forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0)))))) :rule resolution :premises (t60 t63 a7) :args ((= (forall ((?v0 Enat$)) (=> (not (= ?v0 infinity$)) (= (enat$ (the_enat$ ?v0)) ?v0))) (forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0)))))) false (forall ((?v0 Enat$)) (=> (not (= ?v0 infinity$)) (= (enat$ (the_enat$ ?v0)) ?v0))) false))
(step t65 (cl (or (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$))))))) :rule resolution :premises (t59 t64) :args ((forall ((?v0 Enat$)) (or (= infinity$ ?v0) (= ?v0 (enat$ (the_enat$ ?v0))))) false))
(step t66 (cl (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$)))) :rule resolution :premises (t56 t57 t65) :args ((= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$))))) true (or (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (= (times$ (enat$ delta$) (arity_sym$ f$)) (enat$ (the_enat$ (times$ (enat$ delta$) (arity_sym$ f$)))))) false))
(step t67 (cl (or (not (forall ((?v0 Enat$) (?v1 Enat$)) (= (= infinity$ (times$ ?v0 ?v1)) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0))))))) (= (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))))))) :rule forall_inst :args ((enat$ delta$) (arity_sym$ f$)))
(step t68 (cl (not (forall ((?v0 Enat$) (?v1 Enat$)) (= (= infinity$ (times$ ?v0 ?v1)) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0))))))) (= (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))))) :rule or :premises (t67))
(step t69 (cl (not (= (forall ((?v0 Enat$) (?v1 Enat$)) (= (= (times$ ?v0 ?v1) infinity$) (or (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= ?v1 infinity$) (not (= ?v0 zero$)))))) (forall ((?v0 Enat$) (?v1 Enat$)) (= (= infinity$ (times$ ?v0 ?v1)) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0)))))))) (not (forall ((?v0 Enat$) (?v1 Enat$)) (= (= (times$ ?v0 ?v1) infinity$) (or (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= ?v1 infinity$) (not (= ?v0 zero$))))))) (forall ((?v0 Enat$) (?v1 Enat$)) (= (= infinity$ (times$ ?v0 ?v1)) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0))))))) :rule equiv_pos2)
(anchor :step t70 :args ((?v0 Enat$) (?v1 Enat$) (:= (?v0 Enat$) ?v0) (:= (?v1 Enat$) ?v1)))
(step t70.t0 (cl (= (= (times$ ?v0 ?v1) infinity$) (= infinity$ (times$ ?v0 ?v1)))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= (times$ ?v0 ?v1) infinity$) (= infinity$ (times$ ?v0 ?v1))) 2 7))
(step t70.t1 (cl (= (= ?v0 infinity$) (= infinity$ ?v0))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= ?v0 infinity$) (= infinity$ ?v0)) 2 7))
(step t70.t2 (cl (= (= ?v1 zero$) (= zero$ ?v1))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= ?v1 zero$) (= zero$ ?v1)) 2 7))
(step t70.t3 (cl (= (not (= ?v1 zero$)) (not (= zero$ ?v1)))) :rule cong :premises (t70.t2))
(step t70.t4 (cl (= (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= infinity$ ?v0) (not (= zero$ ?v1))))) :rule cong :premises (t70.t1 t70.t3))
(step t70.t5 (cl (= (= ?v1 infinity$) (= infinity$ ?v1))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= ?v1 infinity$) (= infinity$ ?v1)) 2 7))
(step t70.t6 (cl (= (= ?v0 zero$) (= zero$ ?v0))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= ?v0 zero$) (= zero$ ?v0)) 2 7))
(step t70.t7 (cl (= (not (= ?v0 zero$)) (not (= zero$ ?v0)))) :rule cong :premises (t70.t6))
(step t70.t8 (cl (= (and (= ?v1 infinity$) (not (= ?v0 zero$))) (and (= infinity$ ?v1) (not (= zero$ ?v0))))) :rule cong :premises (t70.t5 t70.t7))
(step t70.t9 (cl (= (or (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= ?v1 infinity$) (not (= ?v0 zero$)))) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0)))))) :rule cong :premises (t70.t4 t70.t8))
(step t70.t10 (cl (= (= (= (times$ ?v0 ?v1) infinity$) (or (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= ?v1 infinity$) (not (= ?v0 zero$))))) (= (= infinity$ (times$ ?v0 ?v1)) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0))))))) :rule cong :premises (t70.t0 t70.t9))
(step t70 (cl (= (forall ((?v0 Enat$) (?v1 Enat$)) (= (= (times$ ?v0 ?v1) infinity$) (or (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= ?v1 infinity$) (not (= ?v0 zero$)))))) (forall ((?v0 Enat$) (?v1 Enat$)) (= (= infinity$ (times$ ?v0 ?v1)) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0)))))))) :rule bind)
(step t71 (cl (forall ((?v0 Enat$) (?v1 Enat$)) (= (= infinity$ (times$ ?v0 ?v1)) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0))))))) :rule resolution :premises (t69 t70 a2) :args ((= (forall ((?v0 Enat$) (?v1 Enat$)) (= (= (times$ ?v0 ?v1) infinity$) (or (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= ?v1 infinity$) (not (= ?v0 zero$)))))) (forall ((?v0 Enat$) (?v1 Enat$)) (= (= infinity$ (times$ ?v0 ?v1)) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0))))))) false (forall ((?v0 Enat$) (?v1 Enat$)) (= (= (times$ ?v0 ?v1) infinity$) (or (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= ?v1 infinity$) (not (= ?v0 zero$)))))) false))
(step t72 (cl (= (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))))) :rule resolution :premises (t68 t71) :args ((forall ((?v0 Enat$) (?v1 Enat$)) (= (= infinity$ (times$ ?v0 ?v1)) (or (and (= infinity$ ?v0) (not (= zero$ ?v1))) (and (= infinity$ ?v1) (not (= zero$ ?v0)))))) false))
(step t73 (cl (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))))) :rule resolution :premises (t54 t66 t72) :args ((= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) false (= (= infinity$ (times$ (enat$ delta$) (arity_sym$ f$))) (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))))) false))
(step t74 (cl (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))) :rule resolution :premises (t46 t52 t73) :args ((and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) true (or (and (= infinity$ (enat$ delta$)) (not (= zero$ (arity_sym$ f$)))) (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))) false))
(step t75 (cl (not (= zero$ (enat$ delta$)))) :rule resolution :premises (t44 t74) :args ((and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))) false))
(step t76 (cl (not (= delta$ zero$a))) :rule resolution :premises (t42 t75 a1) :args ((= zero$ (enat$ delta$)) true (= zero$ (enat$ zero$a)) false))
(step t77 (cl (not (= (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= delta$ zero$a))))) (not (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$)))) (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= delta$ zero$a)))) :rule equiv_pos2)
(step t78 (cl (= (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))))) :rule refl)
(step t79 (cl (= (not (less$ zero$a delta$)) (not (less$ zero$a delta$)))) :rule refl)
(step t80 (cl (= (= zero$a delta$) (= delta$ zero$a))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= zero$a delta$) (= delta$ zero$a)) 2 7))
(step t81 (cl (= (= (not (less$ zero$a delta$)) (= zero$a delta$)) (= (not (less$ zero$a delta$)) (= delta$ zero$a)))) :rule cong :premises (t79 t80))
(step t82 (cl (= (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= delta$ zero$a))))) :rule cong :premises (t78 t81))
(step t83 (cl (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) :rule implies_neg1)
(anchor :step t84)
(assume t84.a0 (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))))
(step t84.t0 (cl (or (not (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) (= (not (less$ zero$a delta$)) (= zero$a delta$)))) :rule forall_inst :args (delta$))
(step t84.t1 (cl (not (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) :rule or :premises (t84.t0))
(step t84.t2 (cl (not (= (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))))) (not (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a)))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) :rule equiv_pos2)
(anchor :step t84.t3 :args ((?v0 Nat$) (:= (?v0 Nat$) ?v0)))
(step t84.t3.t0 (cl (= (not (less$ zero$a ?v0)) (not (less$ zero$a ?v0)))) :rule refl)
(step t84.t3.t1 (cl (= (= ?v0 zero$a) (= zero$a ?v0))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= ?v0 zero$a) (= zero$a ?v0)) 2 7))
(step t84.t3.t2 (cl (= (= (not (less$ zero$a ?v0)) (= ?v0 zero$a)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) :rule cong :premises (t84.t3.t0 t84.t3.t1))
(step t84.t3 (cl (= (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))))) :rule bind)
(step t84.t4 (cl (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) :rule resolution :premises (t84.t2 t84.t3 a5) :args ((= (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) false (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a))) false))
(step t84.t5 (cl (= (not (less$ zero$a delta$)) (= zero$a delta$))) :rule resolution :premises (t84.t1 t84.t4) :args ((forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) false))
(step t84 (cl (not (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) :rule subproof :discharge (t84.a0))
(step t85 (cl (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) :rule resolution :premises (t83 t84) :args ((forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) true))
(step t86 (cl (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) (not (= (not (less$ zero$a delta$)) (= zero$a delta$)))) :rule implies_neg2)
(step t87 (cl (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$)))) :rule resolution :premises (t85 t86) :args ((= (not (less$ zero$a delta$)) (= zero$a delta$)) true))
(step t88 (cl (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$)))) :rule contraction :premises (t87))
(step t89 (cl (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= delta$ zero$a)))) :rule resolution :premises (t77 t82 t88) :args ((= (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= delta$ zero$a)))) false (=> (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) (= (not (less$ zero$a delta$)) (= zero$a delta$))) false))
(step t90 (cl (not (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) (= (not (less$ zero$a delta$)) (= delta$ zero$a))) :rule implies :premises (t89))
(step t91 (cl (not (= (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))))) (not (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a)))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) :rule equiv_pos2)
(anchor :step t92 :args ((?v0 Nat$) (:= (?v0 Nat$) ?v0)))
(step t92.t0 (cl (= (not (less$ zero$a ?v0)) (not (less$ zero$a ?v0)))) :rule refl)
(step t92.t1 (cl (= (= ?v0 zero$a) (= zero$a ?v0))) :rule hole :args ("TRUST_THEORY_REWRITE" (= (= ?v0 zero$a) (= zero$a ?v0)) 2 7))
(step t92.t2 (cl (= (= (not (less$ zero$a ?v0)) (= ?v0 zero$a)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) :rule cong :premises (t92.t0 t92.t1))
(step t92 (cl (= (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))))) :rule bind)
(step t93 (cl (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) :rule resolution :premises (t91 t92 a5) :args ((= (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a))) (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0)))) false (forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= ?v0 zero$a))) false))
(step t94 (cl (= (not (less$ zero$a delta$)) (= delta$ zero$a))) :rule resolution :premises (t90 t93) :args ((forall ((?v0 Nat$)) (= (not (less$ zero$a ?v0)) (= zero$a ?v0))) false))
(step t95 (cl (less$ zero$a delta$)) :rule resolution :premises (t28 t76 t94) :args ((= delta$ zero$a) true (= (not (less$ zero$a delta$)) (= delta$ zero$a)) false))
(step t96 (cl (forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0))))) :rule resolution :premises (t14 t95) :args ((less$ zero$a delta$) false))
(step t97 (cl (not (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$))))) (= infinity$ (arity_sym$ f$))) :rule and_pos :args (0))
(step t98 (cl (= infinity$ (arity_sym$ f$)) (not (and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))))) :rule reordering :premises (t97))
(step t99 (cl (= infinity$ (arity_sym$ f$))) :rule resolution :premises (t98 t74) :args ((and (= infinity$ (arity_sym$ f$)) (not (= zero$ (enat$ delta$)))) false))
(step t100 (cl) :rule resolution :premises (t6 t96 t99) :args ((forall ((?v0 S$)) (not (= infinity$ (arity_sym$ ?v0)))) false (= infinity$ (arity_sym$ f$)) false))

