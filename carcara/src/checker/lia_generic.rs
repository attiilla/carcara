use super::*;
use crate::checker::error::LiaGenericError;
use crate::external::*;
use std::collections::HashMap;
use std::process;
use std::{
    fs::File,
    io::Write,
    process::{Command, Stdio},
};

fn sat_refutation_external_check(
    cnf_path: String,
    prelude: &ProblemPrelude,
    checker_path: String,
    lemmas: &Vec<Rc<Term>>,
) -> RuleResult {
    let prelude_path = format!("prelude_{}.smt2", process::id());
    log::info!("[sat_refutation check] Print prelude file {}", prelude_path);
    write!(File::create(prelude_path.clone()).unwrap(), "{}", prelude).unwrap();

    // transform each AND arg, if any, into a string and build a
    // string "(and ... )" so that each lemma has its own names
    let lemmas_as_str = if lemmas.len() == 1 {
        let lemma_or = if let Some((Operator::RareList, lemma_lits)) = lemmas[0].as_op() {
            Term::Op(Operator::Or, lemma_lits.to_vec())
        } else {
            unreachable!();
        };
        format!("{}", lemma_or)
    } else {
        let mut str_aux = String::new();
        use std::fmt::Write;
        write!(&mut str_aux, "(and").unwrap();
        lemmas.iter().for_each(|lemma| {
            let lemma_or = if let Some((Operator::RareList, lemma_lits)) = lemma.as_op() {
                Term::Op(Operator::Or, lemma_lits.to_vec())
            } else {
                unreachable!();
            };
            write!(&mut str_aux, " {}", lemma_or).unwrap();
        });
        write!(&mut str_aux, ")").unwrap();
        str_aux
    };
    let lemmas_path = format!("lemmas_{}.smt2", process::id());
    log::info!("[sat_refutation check] Print lemmas file {}", lemmas_path);
    write!(
        File::create(lemmas_path.clone()).unwrap(),
        "{}",
        lemmas_as_str
    )
    .unwrap();
    log::info!("[sat_refutation check] Invoke oracle");

    let string = format!("(\n{}\n{}\n{}\n)", cnf_path, prelude_path, lemmas_path);
    // this will make it expect this script from where you are running Carcara
    let mut process = Command::new(checker_path.clone())
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(LiaGenericError::FailedSpawnSolver)?;

    process
        .stdin
        .take()
        .expect("failed to open solver stdin")
        .write_all(string.as_bytes())
        .map_err(LiaGenericError::FailedWriteToSolverStdin)?;

    let output = process
        .wait_with_output()
        .map_err(LiaGenericError::FailedWaitForSolver)?;

    if !output.status.success() {
        if let Ok(s) = std::str::from_utf8(&output.stderr) {
            if s.contains("interrupted by timeout.") {
                return Err(CheckerError::Unspecified);
            }
        }
        return Err(CheckerError::Unspecified);
    }
    let res = output.stdout.as_slice();

    if res == b"true\n" {
        return Ok(());
    }
    return Err(CheckerError::Explanation(format!(
        "External checker {} did not validate step",
        checker_path
    )));
}

pub fn sat_refutation(
    RuleArgs { pool, .. }: RuleArgs,
    premise_steps: Vec<&ProofCommand>,
    prelude: &ProblemPrelude,
    checker_path: Option<String>,
    cadical_path: Option<String>,
    drattrim_path: Option<String>,
    cvc5_path: Option<String>,
) -> RuleResult {
    // Create the DIMACS file from the premises and the lemmas.
    //
    // Lemmas (i.e., conclusions of "hole") are non-unit clauses if
    // they are OR terms, and unit otherwise. Literals are going to be
    // generated by doing the "remove_all_negations()" method of
    // terms.
    //
    // For the remaining premises, we can have some of them which
    // occur as arguments in others, which as a safer thing we also
    // add them as unit clauses with a literal corresponding to the
    // whole clause.

    let mut lemmas_to_step_ids: HashMap<Rc<Term>, String> = HashMap::new();
    let mut clause_id_to_lemma: HashMap<usize, Rc<Term>> = HashMap::new();
    let premise_clauses = collect_premise_clauses(
        pool,
        &premise_steps,
        &mut lemmas_to_step_ids,
        &mut clause_id_to_lemma,
    );
    log::info!(
        "[sat_refutation check] Premises yield {} clauses of which {} are lemmas",
        premise_clauses.len(),
        lemmas_to_step_ids.len()
    );

    let mut sat_clause_to_lemma: HashMap<Vec<i32>, Rc<Term>> = HashMap::new();
    let mut term_to_var: HashMap<&Rc<Term>, i32> = HashMap::new();
    match checker_path {
        Some(checker_path) => {
            let cnf_path = gen_dimacs(
                &premise_clauses,
                &clause_id_to_lemma,
                &mut sat_clause_to_lemma,
                &mut term_to_var,
                true,
            );
            // Note that I have to get these lemmas aligned with the
            // order in which they are printed in the CNF, which is
            // guaranteed if I follow the same order of
            // premise_clauses
            let lemmas: Vec<Rc<Term>> = (0..premise_clauses.len())
                .filter_map(|i| {
                    if let Some(lemma) = clause_id_to_lemma.get(&i) {
                        Some(lemma.clone())
                    } else {
                        None
                    }
                })
                .collect();

            if clause_id_to_lemma.len() != lemmas.len() {
                return Err(CheckerError::Explanation(format!(
                    "{} lemmas in CNF but {} lemma terms",
                    clause_id_to_lemma.len(),
                    lemmas.len()
                )));
            }
            sat_refutation_external_check(cnf_path, prelude, checker_path, &lemmas)
        }
        None => {
            let cnf_path = gen_dimacs(
                &premise_clauses,
                &clause_id_to_lemma,
                &mut sat_clause_to_lemma,
                &mut term_to_var,
                false,
            );

            match get_core_lemmas(
                cnf_path,
                &sat_clause_to_lemma,
                cadical_path.unwrap(),
                drattrim_path.unwrap(),
            ) {
                Ok(core_lemmas) => {
                    log::info!(
                        "[sat_refutation check] Check {} core lemmas",
                        core_lemmas.len()
                    );
                    let borrowed_term_pool = pool;
                    let primitive_pool: &mut PrimitivePool = match borrowed_term_pool
                        .as_any_mut()
                        .downcast_mut::<PrimitivePool>()
                    {
                        Some(b) => b,
                        None => panic!("&a isn't a B!"),
                    };
                    let cvc5_path = cvc5_path.unwrap();
                    // for each core lemma, we will run cvc5, parse the proof in, and check it
                    for i in 0..core_lemmas.len() {
                        // println!("\tCheck lemma {:?}", lemma);
                        let problem =
                            get_problem_string(primitive_pool, &prelude, &core_lemmas[i][..]);

                        if let Err(e) =
                            get_solver_proof(primitive_pool, problem.clone(), &cvc5_path)
                        {
                            println!("\t\tFailed: {:?}", core_lemmas[i]);
                            return Err(CheckerError::External(e));
                        }
                    }
                    log::info!("[sat_refutation check] All successfully checked");
                    return Ok(());
                }
                Err(e) => return Err(CheckerError::External(e)),
            }
        }
    }
}

pub fn external_checker(RuleArgs { args, .. }: RuleArgs, checker_path: String) -> RuleResult {
    let args_str: Vec<String> = args.iter().map(|t| format!("{}", t)).collect();
    let string = format!("(\n{}\n)", args_str.join("\n"));
    // this will make it expect this script from where you are running Carcara
    let mut process = Command::new(checker_path.clone())
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(LiaGenericError::FailedSpawnSolver)?;

    process
        .stdin
        .take()
        .expect("failed to open solver stdin")
        .write_all(string.as_bytes())
        .map_err(LiaGenericError::FailedWriteToSolverStdin)?;

    let output = process
        .wait_with_output()
        .map_err(LiaGenericError::FailedWaitForSolver)?;

    if !output.status.success() {
        if let Ok(s) = std::str::from_utf8(&output.stderr) {
            if s.contains("interrupted by timeout.") {
                return Err(CheckerError::Unspecified);
            }
        }
        return Err(CheckerError::Unspecified);
    }
    let res = output.stdout.as_slice();
    if res == b"true\n" {
        return Ok(());
    }
    return Err(CheckerError::Explanation(format!(
        "External checker {} did not validate step",
        checker_path
    )));
}
