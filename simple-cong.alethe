(assume a0 (= a b))
(assume a1 (= c d))
(assume a2 (and p1 true))
(assume a3 (or (not p1) (and p2 p3)))
(assume a4 (or (not p3) (not (= (f (+ a 0) c) (f b d)))))
(step t0 (cl (and (or (and p2 p3) (not p3) (not p2)) (or p3 (not (and p2 p3))) (or p2 (not (and p2 p3))) p1 (= c d) (or (not p3) (not (= (f b d) (f a c)))) (or (not p1) (and p2 p3)) (= a b)) (not (or (and p2 p3) (not p3) (not p2))) (not (or p3 (not (and p2 p3)))) (not (or p2 (not (and p2 p3)))) (not p1) (not (= c d)) (not (or (not p3) (not (= (f b d) (f a c))))) (not (or (not p1) (and p2 p3))) (not (= a b))) :rule and_neg)
(step t1 (cl (and p2 p3) (not p2) (not p3)) :rule and_neg)
(step t2 (cl (and p2 p3) (not p3) (not p2)) :rule reordering :premises (t1))
(step t3 (cl (or (and p2 p3) (not p3) (not p2)) (not (and p2 p3))) :rule or_neg :args (0))
(step t4 (cl (or (and p2 p3) (not p3) (not p2)) (not (not p3))) :rule or_neg :args (1))
(step t5 (cl (or (and p2 p3) (not p3) (not p2)) (not (not p2))) :rule or_neg :args (2))
(step t6 (cl (or (and p2 p3) (not p3) (not p2)) (or (and p2 p3) (not p3) (not p2)) (or (and p2 p3) (not p3) (not p2))) :rule resolution :premises (t2 t3 t4 t5))
(step t7 (cl (or (and p2 p3) (not p3) (not p2))) :rule contraction :premises (t6))
(step t8 (cl (not (and p2 p3)) p3) :rule and_pos :args (1))
(step t9 (cl p3 (not (and p2 p3))) :rule reordering :premises (t8))
(step t10 (cl (or p3 (not (and p2 p3))) (not p3)) :rule or_neg :args (0))
(step t11 (cl (or p3 (not (and p2 p3))) (not (not (and p2 p3)))) :rule or_neg :args (1))
(step t12 (cl (or p3 (not (and p2 p3))) (or p3 (not (and p2 p3)))) :rule resolution :premises (t9 t10 t11))
(step t13 (cl (or p3 (not (and p2 p3)))) :rule contraction :premises (t12))
(step t14 (cl (not (and p2 p3)) p2) :rule and_pos :args (0))
(step t15 (cl p2 (not (and p2 p3))) :rule reordering :premises (t14))
(step t16 (cl (or p2 (not (and p2 p3))) (not p2)) :rule or_neg :args (0))
(step t17 (cl (or p2 (not (and p2 p3))) (not (not (and p2 p3)))) :rule or_neg :args (1))
(step t18 (cl (or p2 (not (and p2 p3))) (or p2 (not (and p2 p3)))) :rule resolution :premises (t15 t16 t17))
(step t19 (cl (or p2 (not (and p2 p3)))) :rule contraction :premises (t18))
(step t20 (cl p1) :rule and :premises (a2) :args (0))
(step t21 (cl (not (= (or (not p3) (not (= (f (+ a 0) c) (f b d)))) (or (not p3) (not (= (f b d) (f a c)))))) (not (or (not p3) (not (= (f (+ a 0) c) (f b d))))) (or (not p3) (not (= (f b d) (f a c))))) :rule equiv_pos2)
(step t22 (cl (= (not p3) (not p3))) :rule refl)
(step t23 (cl (= (+ a 0) a)) :rule all_simplify)
(step t24 (cl (= c c)) :rule refl)
(step t25 (cl (= (f (+ a 0) c) (f a c))) :rule cong :premises (t23 t24))
(step t26 (cl (= (f b d) (f b d))) :rule refl)
(step t27 (cl (= (= (f (+ a 0) c) (f b d)) (= (f a c) (f b d)))) :rule cong :premises (t25 t26))
(step t28 (cl (= (= (f a c) (f b d)) (= (f b d) (f a c)))) :rule all_simplify)
(step t29 (cl (= (= (f (+ a 0) c) (f b d)) (= (f b d) (f a c)))) :rule trans :premises (t27 t28))
(step t30 (cl (= (not (= (f (+ a 0) c) (f b d))) (not (= (f b d) (f a c))))) :rule cong :premises (t29))
(step t31 (cl (= (or (not p3) (not (= (f (+ a 0) c) (f b d)))) (or (not p3) (not (= (f b d) (f a c)))))) :rule cong :premises (t22 t30))
(step t32 (cl (or (not p3) (not (= (f b d) (f a c))))) :rule resolution :premises (t21 t31 a4))
(step t33 (cl (and (or (and p2 p3) (not p3) (not p2)) (or p3 (not (and p2 p3))) (or p2 (not (and p2 p3))) p1 (= c d) (or (not p3) (not (= (f b d) (f a c)))) (or (not p1) (and p2 p3)) (= a b))) :rule resolution :premises (t0 t7 t13 t19 t20 a1 t32 a3 a0))
(step t34 (cl (or (= (f b d) (f a c)) (not (= a b)) (not (= c d)))) :rule hole :args ("THEORY_LEMMA" (or (= (f b d) (f a c)) (not (= a b)) (not (= c d)))))
(step s0 (cl (or (not (= a c)) (not (= c b)) (= a b))) :rule hole)
(step t35 (cl false) :rule sat_refutation :premises (t2 t9 t15 t20 a1 t32 a3 a0 t34 s0))
(step t36 (cl (not false)) :rule false)
(step t37 (cl) :rule resolution :premises (t35 t36))
